#
# The stop_slave_quick suite of tests aims to validate that stopping a replica
# with parallelization enabled will stop in a timely manner. That is, a
# parallel replica should try to immediately stop and roll-back any ongoing
# transactions. If any threads have a non-transactional workload, then it
# along with all prior transactions are executed before stopping.
#
# This file provides test cases that should be binlog format independent. There
# is, however, behavior that is specific to either statement or row format,
# which each have their own test files that include this file.
#
# Requirements:
#   1. Tables named `ti`, `ti2`, and `ti3` have already been created with
#      storage engine InnoDB; and a table named `tm` has been created with
#      storage engine MyIsam.
#   2. Test variables ti_ctr, ti2_ctr, ti3_ctr, and tm_ctr have been created
#      to serve as dynamic values to insert into their respective tables
#
# References:
#   MDEV-13915: STOP SLAVE takes very long time on a busy system
#

--echo #
--echo # Common Test Case 1:
--echo # Using one parallel replication worker thread on workload {T,T}, ensure
--echo # the replica immediately rolls back the transaction and stops the
--echo # SQL thread
--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from ti`

--connection master
--source include/save_master_gtid.inc
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
LOCK TABLES ti WRITE;
--source include/start_slave.inc

--echo # Wait for replica to begin executing the first transaction
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from ti`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No new rows should have been inserted
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should not change
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Common Test Case 2:
--echo # Using multiple parallel replication threads (two) on workload {T,T},
--echo # ensure both transactions are rolled back if stop slave is issued
--echo # in the middle of the first transaction.

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=2;
--let $row_count_initial=`select count(*) from ti`

--connection master
--source include/save_master_gtid.inc
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
LOCK TABLES ti WRITE;
--source include/start_slave.inc

--echo # Wait for replica to begin executing the first transaction
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--echo # Wait for second transaction to begin
--connection slave
--let $wait_condition= SELECT count(*)=0 FROM information_schema.processlist WHERE state LIKE 'Waiting for work from SQL thread' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from ti`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No insertions should have committed
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should not change
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Common Test Case 3:
--echo # Using multiple parallel replication threads (two) on workload {T,T},
--echo # with the same commit id (cid), ensure both transactions are rolled
--echo # back if stop slave is issued

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_mode=AGGRESSIVE;
set @@global.slave_parallel_threads=2;
--let $row_count_initial=`select count(*) from ti`

--connection master
--source include/save_master_gtid.inc
SET @old_dbug= @@SESSION.debug_dbug;
SET @@SESSION.debug_dbug="+d,binlog_force_commit_id";
SET @commit_id= 10000;
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;
--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr

SET @@SESSION.debug_dbug=@old_dbug;

--connection slave
LOCK TABLES ti WRITE;
--source include/start_slave.inc

--echo # Wait for replica to begin executing the first transactions
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--echo # Wait for second transaction to start group commit
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $row_count_end=`select count(*) from ti`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No insertions should have committed
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should not change
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc

--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Common Test Case 4:
--echo # Using multiple parallel replication threads (4) on workload
--echo #    T (long running); should commit
--echo #    N (waiting for prior commit); should commit
--echo #    T (long running); should rollback
--echo #    T (waiting for prior commit); should rollback
--echo # Issuing STOP SLAVE should allow the first two transactions to commit
--echo # while preventing and rolling back the third
--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_mode=optimistic;
set @@global.slave_parallel_threads=4;

--connection master
SET @old_dbug= @@SESSION.debug_dbug;
SET @@SESSION.debug_dbug="+d,binlog_force_commit_id";
SET @commit_id= 10001;
BEGIN;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
COMMIT;

--connection master
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--source include/save_master_gtid.inc

--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr

--eval insert into ti3 values ($ti3_ctr)
--inc $ti3_ctr

SET @@SESSION.debug_dbug=@old_dbug;

--connection slave
LOCK TABLES ti WRITE, ti2 WRITE;
--source include/start_slave.inc

--echo # Wait for replica to progress until the transactions targeting locked tables are stuck on their locks..
--let $wait_condition= SELECT count(*)=2 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--echo # Wait for replica to progress until unblocked transactions are queued for group commit..
--connection slave
--let $wait_condition= SELECT count(*)=2 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should reach first N transaction
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

set @@global.slave_parallel_mode=CONSERVATIVE;

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Common Test Case 5:
--echo # Using multiple parallel replication threads (5) on workload
--echo #    T (long running); should commit
--echo #    N (waiting for prior commit); should commit
--echo #    T (waiting for prior commit); should commit
--echo #    N (waiting for prior commit); should commit
--echo #    T (long running); should rollback
--echo # Issuing STOP SLAVE should allow all transactions up to and including
--echo # the last N (4th) to commit, while preventing and rolling back the
--echo # final transaction (5th)

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_mode=optimistic;
set @@global.slave_parallel_threads=5;

--connection master
SET @old_dbug= @@SESSION.debug_dbug;
SET @@SESSION.debug_dbug="+d,binlog_force_commit_id";
SET @commit_id= 10002;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--eval insert into tm values ($tm_ctr)
--inc $tm_ctr

--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr

--eval insert into tm2 values ($tm2_ctr)
--inc $tm2_ctr
--source include/save_master_gtid.inc

--eval insert into ti3 values ($ti3_ctr)
--inc $ti3_ctr

SET @@SESSION.debug_dbug=@old_dbug;

--connection slave
LOCK TABLES ti WRITE, ti3 WRITE;
--source include/start_slave.inc

--echo # Wait for replica to progress until the transactions targeting locked tables are stuck on their locks..
--let $wait_condition= SELECT count(*)=2 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--echo # Wait for replica to progress until unblocked transactions are queued for group commit..
--connection slave
--let $wait_condition= SELECT count(*)=3 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should reach second N transaction
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

set @@global.slave_parallel_mode=CONSERVATIVE;

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Common Test Case 6:
--echo # If retrying a T transaction while STOP SLAVE is issued, the
--echo # transaction should be rolled back and the slave abruptly stopped

--connection master
--eval insert into ti values ($ti_ctr)
--source include/save_master_gtid.inc

--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;

--let $save_innodb_lock_wait_timeout= `SELECT @@global.innodb_lock_wait_timeout`
# 2 second buffer to give ample time to wait for transaction and issue stop slave
set @@global.innodb_lock_wait_timeout= 2;
BEGIN;
--eval SELECT * FROM ti WHERE a=$ti_ctr FOR UPDATE

--connection master
--source include/save_master_gtid.inc
--eval update ti set a=a+1 where a=$ti_ctr
--inc $ti_ctr
--inc $ti_ctr

--connection slave
--source include/start_slave.inc
--let $retried_tx_initial= query_get_value(SHOW ALL SLAVES STATUS, Retried_transactions, 1)

if (`SELECT @@global.binlog_format = 'ROW'`)
{
    --let $update_state=Update_rows_log_event::find_row(-1)
}
if (`SELECT @@global.binlog_format = 'STATEMENT'`)
{
    --let $update_state=Updating
}
--echo # Wait for replicating transaction to wait for innodb table lock
--source include/start_slave.inc
--let $wait_condition= SELECT COUNT(*) > 0 FROM information_schema.processlist WHERE state LIKE "$update_state" and command like 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE FORCE;

connection slave;
--source include/wait_for_slave_sql_to_stop.inc
--let $retried_tx_test= query_get_value(SHOW ALL SLAVES STATUS, Retried_transactions, 1)
if ($retried_tx_initial != $retried_tx_test)
{
    --echo T transaction should have been rolled back without retry
    --die T transaction should have been rolled back without retry
}

# End the SELECT ... FOR UPDATE
ROLLBACK;

--connection slave1
--reap
--connection slave

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= The retried T transaction should have been rolled back
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--eval set @@global.innodb_lock_wait_timeout= $save_innodb_lock_wait_timeout

--echo #
--echo # Common Test Case 7:
--echo # Using multiple parallel replication threads on a workload with a
--echo # non-transactional transaction in-between transactional transactions..
--echo #  7a: with AGGRESSIVE replication where the N statement has been
--echo #      executed already, all transactions up to and including N should
--echo #      be replicated, and all transactions afterwards should be rolled
--echo #      back.
--echo #  7b: with MINIMAL replication, the N statement should not execute
--echo #      concurrently, but should wait along with the other later
--echo #      transactions, and all future transactions except the first should
--echo #      be rolled back.

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=4;

--let $mode_ctr=2
while ($mode_ctr)
{
    --connection slave
    if ($mode_ctr == 2)
    {
        --echo #
        --echo # 7a: slave_parallel_mode=AGGRESSIVE
        set @@global.slave_parallel_mode=AGGRESSIVE;
    }
    if ($mode_ctr == 1)
    {
        --echo #
        --echo # 7b: slave_parallel_mode=MINIMAL
        set @@global.slave_parallel_mode=MINIMAL;
    }

    --connection slave
    --let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2 UNION ALL select * from ti3) t`

    --connection master
    if ($mode_ctr == 1)
    {
        --let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
    }

    --connection master
    --eval insert into ti values ($ti_ctr)
    --inc $ti_ctr

    --eval insert into tm values ($tm_ctr)
    if ($mode_ctr == 2)
    {
        # AGGRESSIVE mode should allow N trx to complete
        --let $master_gtid_cmp= `select @@global.gtid_binlog_pos`
    }
    --eval insert into ti2 values ($ti2_ctr)
    --inc $ti2_ctr
    --eval insert into ti values ($ti_ctr)
    --inc $ti_ctr
    --source include/save_master_gtid.inc

    --connection slave
    LOCK TABLES ti WRITE;
    --connection slave_lock_extra
    LOCK TABLES ti2 WRITE;

    --source include/start_slave.inc

    --echo # Wait for replica to halt due to locks and dependency requirements
    --connection slave

    if ($mode_ctr == 2)
    {
        # AGGRESSIVE allows for more concurrency that we need to wait for
        --let $wait_condition= SELECT count(*)=3 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
        --let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
    }
    if ($mode_ctr == 1)
    {
        # MINIMAL will only have the first transaction begun
        --let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
        --let $wait_condition= SELECT count(*)=3 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to start commit%' and  command LIKE 'Slave_worker';
        --source include/wait_condition.inc
    }

    --connection slave1
    --send STOP SLAVE FORCE;

    --connection slave
    --echo # Wait for replica to signal worker threads to stop
    --let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker threads to stop';
    --source include/wait_condition.inc

    UNLOCK TABLES;
    --connection slave_lock_extra
    UNLOCK TABLES;

    --connection slave1
    --reap
    --connection slave
    --source include/wait_for_slave_sql_to_stop.inc

    --let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm UNION ALL select * from ti2 UNION ALL select * from tm2 UNION ALL select * from ti3) t`
    --let $row_count_diff=`select ($row_count_end-$row_count_initial)`

    if ($mode_ctr == 2)
    {
        --let $assert_text= The entirety of the first two transactions should have committed with AGGRESSIVE parallelization
        --let $assert_cond= $row_count_diff = 2
    }
    if ($mode_ctr == 1)
    {
        --let $assert_text= All transactions should have rolled back with MINIMAL parallelization
        --let $assert_cond= $row_count_diff = 0
    }

    --source include/assert.inc

    --let $slave_gtid= `select @@global.gtid_slave_pos`
    --let $assert_text= Slave state should be consistent
    --let $assert_cond= $master_gtid_cmp = $slave_gtid
    --source include/assert.inc

    --connection master
    --source include/save_master_gtid.inc
    --connection slave
    --source include/start_slave.inc
    --source include/sync_with_master_gtid.inc

    --source include/stop_slave.inc
    --dec $mode_ctr
}
--source include/start_slave.inc

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/master-slave.inc

--let $num_threads= 8

--let $rpl_connection_name= slave2
--let $rpl_server_number= 2
--source include/rpl_connect.inc

--connection slave
--source include/stop_slave.inc
SET @old_parallel_threads= @@GLOBAL.slave_parallel_threads;
eval SET GLOBAL slave_parallel_threads= $num_threads;
SET @old_parallel_mode= @@GLOBAL.slave_parallel_mode;
SET GLOBAL slave_parallel_mode=optimistic;
SET @old_dbug= @@GLOBAL.debug_dbug;
CHANGE MASTER TO master_use_gtid=slave_pos;
--source include/start_slave.inc

--connection master
--echo *** Prepare some base data for some parallel transactions to update.
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
CREATE TABLE t1 (a INT PRIMARY KEY, b INT) ENGINE=InnoDB;
INSERT INTO t1 VALUES (0,0);
BEGIN;
--disable_query_log
--let $i = 1
while ($i <= $num_threads)
{
  eval INSERT INTO t1 VALUES ($i, 0);
  eval INSERT INTO t1 VALUES ($i+200, 0);
  inc $i;
}
INSERT INTO t1 VALUES (999, 0);
--enable_query_log
COMMIT;
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc

--connection slave1
--echo *** Block most transactions from completing, so we can check that STOP SLAVE FORCE aborts them.
BEGIN;
--disable_result_log
SELECT * FROM t1 WHERE a>=200 AND a<300 FOR UPDATE;
--enable_result_log

--connection slave
--source include/start_slave.inc

--connection master
--echo *** The main queries. The first query may or may not be replicated before
--echo *** STOP SLAVE FORCE, but all the rest should be aborted.
--let $gtid1= `SELECT @@GLOBAL.gtid_binlog_pos`
--disable_query_log
INSERT INTO t1 VALUES (1000, 0);
--let $gtid2= `SELECT @@GLOBAL.gtid_binlog_pos`
--let $i= 2
while ($i < $num_threads)
{
  BEGIN;
  # First a query that doesn't conflict with anything.
  eval INSERT INTO t1 VALUES ($i+100, 0);
  # Then a query with a few conflicts against other transactions.
  eval UPDATE t1 SET b=b+1 WHERE a=$i MOD 5;
  # Finally a query that we will block on the slave so STOP SLAVE FORCE will
  # need to roll it back.
  eval UPDATE t1 SET b=1 WHERE a=$i+200;
  COMMIT;
  inc $i;
}
eval INSERT INTO t1 VALUES (1001, $num_threads-1);
--enable_query_log

--connection slave2

# Deliberately non-deterministic scheduling with sleep(), to test
# different states of the threads all lead to the expected stop.
--sleep 0.1
SET GLOBAL debug_dbug="+d,rpl_parallel_wait_for_done_trigger";
send STOP SLAVE FORCE;

--connection slave
SET debug_sync="now WAIT_FOR wait_for_done_waiting";

--connection slave1
--echo *** Now allow transactions to complete the blocked query. They should all
--echo *** abort the final COMMIT/XID event since STOP SLAVE FORCE is in progress.
ROLLBACK;

--connection slave2
reap;

--connection slave
--source include/wait_for_slave_to_stop.inc

# Test that we stop on either $gtid1 (no query had time to complete
# before stop), or $gtid2 (the first query had time to complete, but
# the rest were blocked by external query and had to roll back).
--echo *** Check that STOP SLAVE FORCE stops early, aborting active transactions.
let $check=`
  SELECT IF(@@GLOBAL.gtid_slave_pos='$gtid1' OR @@GLOBAL.gtid_slave_pos='$gtid2',
            'Yes, correct',
	    CONCAT("INCORRECT, GTID ", @@GLOBAL.gtid_slave_pos,
	           ", expected $gtid1 or $gtid2"))
  `;
eval SELECT '$check' AS correct_slave_stop_pos;

--echo *** Clean up.
SET DEBUG_SYNC= "RESET";
SET GLOBAL slave_parallel_threads= @old_parallel_threads;
SET GLOBAL slave_parallel_mode= @old_parallel_mode;
SET GLOBAL debug_dbug=@old_dbug;
--source include/start_slave.inc

--connection master
DROP TABLE t1;
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc

--source include/rpl_end.inc

create table t1 (
col1 varchar(32), 
col2 varchar(32), 
key(col1),
key(col2)
) collate utf8mb3_general_ci;
insert into t1
select 
concat('A-', seq),
concat('A-', seq)
from seq_1_to_100;
analyze table t1 persistent for all;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Engine-independent statistics collected
test.t1	analyze	status	Table is already up to date
# Basic examples. All should use ref(col1):
explain
select * from t1 where upper(col1)='A-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	col1	col1	99	const	1	Using index condition
select * from t1 where upper(col1)='A-3';
col1	col2
A-3	A-3
explain
select * from t1 where ucase(col1)='a-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	col1	col1	99	const	1	Using index condition
select * from t1 where ucase(col1)='a-3';
col1	col2
A-3	A-3
explain select * from t1 where 'abc'=upper(col1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	col1	col1	99	const	1	Using index condition
explain select * from t1 where 'xyz'=ucase(col1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	col1	col1	99	const	1	Using index condition
#
# Check if optimizer_switch turns this off:
#
set 
@save_os=@@optimizer_switch, 
optimizer_switch='sargable_casefold=off';
explain select * from t1 where upper(col1)='A-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
explain select * from t1 where ucase(col1)='a-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
set optimizer_switch=@save_os;
#
# Check optimizer trace coverage
#
set
@tmp_ot= @@optimizer_trace,
optimizer_trace=1;
explain select * from t1 where 'abc'=upper(col1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	col1	col1	99	const	1	Using index condition
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
[
    {
        "before": "'abc' = ucase(t1.col1)",
        "after": "'abc' = t1.col1"
    }
]
explain select * from t1 where ucase(col2)=upper(col1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
[
    {
        "before": "ucase(t1.col2) = ucase(t1.col1)",
        "after": "t1.col2 = t1.col1"
    }
]
# The following will not do the rewrite because the comparison
# is done as DOUBLEs. Come to think of it, it won't harm to do
# the rewrite but it is outside of the scope of this patch:
explain select * from t1 where ucase(col1)=123.456;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
NULL
select
coercibility(upper(col1))
from t1 limit 1;
coercibility(upper(col1))
2
select coercibility(_utf8mb3'abc' COLLATE utf8mb3_bin);
coercibility(_utf8mb3'abc' COLLATE utf8mb3_bin)
0
explain select * from t1 where ucase(col1)=_utf8mb3'abc' COLLATE utf8mb3_bin;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
# Will not do the rewrite due to collation mismatch:
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
NULL
explain select * from t1 where ucase(col1 COLLATE utf8mb3_bin)='abc';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
# Will not do the rewrite due to collation mismatch:
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
NULL
set optimizer_trace=@tmp_ot;
# This is transformed too even if it doesn't create any new
# [potential] access paths:
explain format=json select * from t1 where upper(col1)=upper(col2);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100,
      "attached_condition": "t1.col2 = t1.col1"
    }
  }
}
create table t2 (
a varchar(32),
non_key varchar(32),
key(a)
) collate utf8mb3_general_ci;
insert into t2
select
concat('A-', seq),
concat('A-', seq)
from seq_1_to_10;
# Must use ref access for t1:
explain select * from t1, t2 where upper(t1.col1)= t2.non_key;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t1	ref	col1	col1	99	test.t2.non_key	1	
create table t3 (
a varchar(32),
b varchar(32),
key(a),
key(b)
) collate utf8mb3_general_ci;
insert into t3 values ('abc','ABC'), ('xyz','XYZ');
explain extended
select a from t3 where a=b and b='ABC';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	t3	ref|filter	a,b	a|b	99|99	const	1 (50%)	50.00	Using index condition; Using where; Using rowid filter
Warnings:
Note	1003	select `test`.`t3`.`a` AS `a` from `test`.`t3` where `test`.`t3`.`b` = `test`.`t3`.`a` and `test`.`t3`.`a` = 'ABC'
select a from t3 where a=b and b='ABC';
a
abc
#
# Check that rewrite isn't applied for non-applicable collations
#
create table t4 (
col1 varchar(32) collate utf8mb3_bin,
col2 varchar(32) collate utf8mb3_czech_ci,
col3 varchar(32) collate latin1_bin,
key(col1),
key(col2),
key(col3)
);
insert into t4
select 
concat('A-', seq),
concat('A-', seq),
concat('A-', seq)
from seq_1_to_100;
analyze table t4 persistent for all;
Table	Op	Msg_type	Msg_text
test.t4	analyze	status	Engine-independent statistics collected
test.t4	analyze	status	Table is already up to date
# None should use ref access:
explain select * from t4 where upper(col1)='A-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ALL	NULL	NULL	NULL	NULL	100	Using where
explain select * from t4 where upper(col2)='a-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ALL	NULL	NULL	NULL	NULL	100	Using where
explain select * from t4 where upper(col3)='a-3';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t4	ALL	NULL	NULL	NULL	NULL	100	Using where
#
# Check that rewrite works for UPPER(col) IN (const-list)
#
set
@tmp_ot= @@optimizer_trace,
optimizer_trace=1;
# must use range:
explain
select * from t1 where upper(col1) IN ('A-3','A-4','a-5');
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	col1	col1	99	NULL	3	Using index condition
select * from t1 where upper(col1) IN ('A-3','A-4','a-5');
col1	col2
A-3	A-3
A-4	A-4
A-5	A-5
# Will show the rewrite:
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
[
    {
        "before": "ucase(t1.col1) in ('A-3','A-4','a-5')",
        "after": "t1.col1 in ('A-3','A-4','a-5')"
    }
]
explain
select * from t1 where upper(col1) IN ('A-3','A-4',col2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
# Will not show the rewrite:
select 
json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
JS
NULL
set optimizer_trace=@tmp_ot;
drop table t1,t2,t3,t4;

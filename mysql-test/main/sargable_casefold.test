--source include/have_sequence.inc
--source include/not_embedded.inc

create table t1 (
  col1 varchar(32), 
  col2 varchar(32), 
  key(col1),
  key(col2)
) collate utf8mb3_general_ci;

insert into t1
select 
  concat('A-', seq),
  concat('A-', seq)
from seq_1_to_100;

analyze table t1 persistent for all;

--echo # Basic examples. All should use ref(col1):
explain
select * from t1 where upper(col1)='A-3';
select * from t1 where upper(col1)='A-3';

explain
select * from t1 where ucase(col1)='a-3';
select * from t1 where ucase(col1)='a-3';

explain select * from t1 where 'abc'=upper(col1);
explain select * from t1 where 'xyz'=ucase(col1);

--echo #
--echo # Check if optimizer_switch turns this off:
--echo #

set 
  @save_os=@@optimizer_switch, 
  optimizer_switch='sargable_casefold=off';
explain select * from t1 where upper(col1)='A-3';
explain select * from t1 where ucase(col1)='a-3';

set optimizer_switch=@save_os;

--echo #
--echo # Check optimizer trace coverage
--echo #
set
  @tmp_ot= @@optimizer_trace,
  optimizer_trace=1;
explain select * from t1 where 'abc'=upper(col1);
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

explain select * from t1 where ucase(col2)=upper(col1);
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

--echo # The following will not do the rewrite because the comparison
--echo # is done as DOUBLEs. Come to think of it, it won't harm to do
--echo # the rewrite but it is outside of the scope of this patch:
explain select * from t1 where ucase(col1)=123.456;
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

select
  coercibility(upper(col1))
from t1 limit 1;
select coercibility(_utf8mb3'abc' COLLATE utf8mb3_bin);

explain select * from t1 where ucase(col1)=_utf8mb3'abc' COLLATE utf8mb3_bin;
--echo # Will not do the rewrite due to collation mismatch:
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

explain select * from t1 where ucase(col1 COLLATE utf8mb3_bin)='abc';
--echo # Will not do the rewrite due to collation mismatch:
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

set optimizer_trace=@tmp_ot;

--echo # This is transformed too even if it doesn't create any new
--echo # [potential] access paths:
explain format=json select * from t1 where upper(col1)=upper(col2);

create table t2 (
  a varchar(32),
  non_key varchar(32),
  key(a)
) collate utf8mb3_general_ci;

insert into t2
select
  concat('A-', seq),
  concat('A-', seq)
from seq_1_to_10;

--echo # Must use ref access for t1:
explain select * from t1, t2 where upper(t1.col1)= t2.non_key;


# Check the interplay with equality propagation

create table t3 (
  a varchar(32),
  b varchar(32),
  key(a),
  key(b)
) collate utf8mb3_general_ci;
insert into t3 values ('abc','ABC'), ('xyz','XYZ');

explain extended
select a from t3 where a=b and b='ABC';
select a from t3 where a=b and b='ABC';

--echo #
--echo # Check that rewrite isn't applied for non-applicable collations
--echo #
create table t4 (
  col1 varchar(32) collate utf8mb3_bin,
  col2 varchar(32) collate utf8mb3_czech_ci,
  col3 varchar(32) collate latin1_bin,
  key(col1),
  key(col2),
  key(col3)
);

insert into t4
select 
  concat('A-', seq),
  concat('A-', seq),
  concat('A-', seq)
from seq_1_to_100;

analyze table t4 persistent for all;

--echo # None should use ref access:
explain select * from t4 where upper(col1)='A-3';
explain select * from t4 where upper(col2)='a-3';
explain select * from t4 where upper(col3)='a-3';


--echo #
--echo # Check that rewrite works for UPPER(col) IN (const-list)
--echo #
set
  @tmp_ot= @@optimizer_trace,
  optimizer_trace=1;

--echo # must use range:
explain
select * from t1 where upper(col1) IN ('A-3','A-4','a-5');
select * from t1 where upper(col1) IN ('A-3','A-4','a-5');

--echo # Will show the rewrite:
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;

explain
select * from t1 where upper(col1) IN ('A-3','A-4',col2);
--echo # Will not show the rewrite:
select 
  json_detailed(json_extract(trace, '$**.sargable_casefold_removal')) as JS
from information_schema.optimizer_trace;
set optimizer_trace=@tmp_ot;

drop table t1,t2,t3,t4;

